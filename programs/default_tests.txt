absInfer := \x.x

inferW1 := let i = \y.\x.x y in i i

inferW2 := let x = \z.\y.z y y in x x

inferW2' := let x = \y.\z.z y y in x x

inferW3 := let x = \z.\w.z w in Î»z.z (x x)

comm := "absInferErr is supposed to be a type error,
just like this one (comm) is supposed to be a parse error"

absInferErr := \x.x x

fakehalfturingcomb := \x.\y.x (y x x)

halfturingcomb := \x.\y.y (x x y)

infer1 := \x.\y.\z.\a.\b.\c.x y z a b c

infer2 := x y z y x

infer3 := \x.\y.x y (z y)

infer4 := (\x.\y.x y) (\x.\z.z x x x)

absCheck := \x:Nat.x

suc := \x:Nat.succ x

sucpred0 := succ (pred 0)

not := \b:Bool.if b then false else true

seq := (\x:Unit.x)unit;pred 0

asc := (\f:Nat->Nat.\x:Nat.f(f x)) as (Nat -> Nat) -> Nat -> Nat

sum2plus4 :=
  (\m:(Nat->Nat)->Nat->Nat.\n:(Nat->Nat)->Nat->Nat.\f:Nat->Nat.\x:Nat.n f (m f x))
    (\f:Nat->Nat.\x:Nat.f(f x))
    (\f:Nat->Nat.\x:Nat.f(f(f(f x))))
    (\x:Nat.succ x)
    0

sum :=
  (\m:(Nat->Nat)->Nat->Nat.
    \n:(Nat->Nat)->Nat->Nat.
      \f:Nat->Nat.
        \x:Nat.
          n f (m f x))
  as
    ((Nat -> Nat) -> Nat -> Nat)
      -> ((Nat -> Nat) -> Nat -> Nat)
      -> (Nat -> Nat)
      -> Nat
      -> Nat

testwild := \_:Nat.\x:Bool.x

case_wildcard_variants :=
  (let g = \_:Bool->Bool.\c:<phys:{a:Nat, Nat}, virt:{a:Nat, Nat}>.
    case c of
        <phys=x> -> x.a
      | <virt=y> -> y.2
  in (g (\x:Bool.x)) ((if iszero (succ (pred 0)) then unit else unit);<virt={a=0,succ 0}> as <phys:{a:Nat, Nat}, virt:{a:Nat, Nat}>)) as Nat

pattern_matching := let {{first = x, first2 = a}, second = y, third = z} = {{first = 0, first2 = succ (succ (succ 0))}, second = succ 0, third = succ (succ 0)} in (if true then a else y) as Nat

records := \x:{one:Nat, Nat}.x.2

recordsApplied := (\x:{one:Nat, Nat}.x.one) {one = succ 0, succ (pred (succ (pred 0)))}

iseven3 := (fix
  (\h:Nat->Bool.
    \x:Nat.
      if iszero x
        then true
      else if iszero (pred x)
        then false
        else h (pred (pred x))) (succ (succ (succ 0))))

iseven := fix
  (\h:Nat->Bool.
    \x:Nat.
      if iszero x
        then true
      else if iszero (pred x)
        then false
        else h (pred (pred x)))

head := \x:List Nat.head[Nat] x

headApplied :=
  (\x:List Nat.head[Nat] x) (cons[Nat] 0 (cons[Nat] (succ 0) nil[Nat]))

simpleBoolList :=
  if isnil[Unit] (cons[Unit] unit nil[Unit])
    then \x:Unit.\y:Unit.x
    else \x:Unit.\y:Unit.y

sum2 :=
  letrec p:Nat->Nat->Nat =
    \m:Nat.
      \n:Nat.
        if iszero m
          then n
          else succ (p (pred m) n)
  in
    p (succ (succ 0)) (succ 0)

piercefullpoly1 := lambda X. lambda x:X. x

piercefullpoly2 := (lambda X. lambda x:X. x) [All X.X->X]

piercefullpoly3 := {*All Y.Y, lambda x:(All Y.Y). x} as {Some X,X->X}

piercefullpoly4 := lambda x:Bool. x

piercefullpoly5 := (lambda x:Bool->Bool. if x false then true else false) 
  (lambda x:Bool. if x then false else true)

piercefullpoly6 := lambda x:Nat. succ x

piercefullpoly7 := (lambda x:Nat. succ (succ x)) (succ 0)

piercefullpoly8 := {x=true, y=false}

piercefullpoly9 := {x=true, y=false}.x

piercefullpoly10 := {true, false}

piercefullpoly11 := {true, false}.1

piercefullpoly12 := {*Nat, {c=0, f=lambda x:Nat. succ x}}
  as {Some X, {c:X, f:X->Nat}}

piercefullpoly13 := let {X,ops} = {*Nat, {c=0, f=lambda x:Nat. succ x}}
              as {Some X, {c:X, f:X->Nat}}
in (ops.f ops.c)

piercefullpoly14 := lambda f:Nat->Nat. lambda x:Nat. f (f x)

piercefullpoly15 := unit

piercefullpoly16 := let x=true in x

piercefullpoly17 := lambda x:A. x

systemF1 := \X.\x:X.x

systemF2 := \X.\x:X.\Y.\y:Y.x

systemF3 :=
  (\Y.\x:All X.X->Nat.\y:Y.x[Y]y)
    [Bool] (\Z.\x:Z.0)
    true

piercearith1 := true

piercearith2 := if false then true else false

piercearith3 := 0

piercearith4 := succ (pred 0)

piercearith5 := iszero (pred (succ (succ 0)))

piercesimplebool1 := lambda x:Bool. x
piercesimplybool2 :=
  (lambda x:Bool->Bool. if x false then true else false) 
    (lambda x:Bool. if x then false else true)

pierceuntyped1 := x

pierceuntyped2 := lambda x. x

pierceuntyped3 := (lambda x. x) (lambda x. x x)

piercereconbase1 := lambda x:Bool. x

piercereconbase2 :=
  (lambda x:Bool->Bool. if x false then true else false) 
    (lambda x:Bool. if x then false else true)

piercereconbase3 := lambda x:Nat. succ x

piercereconbase4 := (lambda x:Nat. succ (succ x)) (succ 0)

piercereconbase5 := lambda x:A. x

piercerecon1 := (lambda x:X. lambda y:X->X. y x)

piercerecon2 := (lambda x:X->X. x 0) (lambda y:Nat. y)

piercefull1 := iszero (pred (succ (succ 0)))

piercerandom1 := lambda x:<a:Bool,b:Bool>.x

piercerandom2 := let f = lambda x. x in (f f) (f 0)

piercerandom3 := let g = lambda x. (\f.\x.f x) in g (g g)

piercefomega1 := (lambda X. lambda x:X. x) [All X.X->X]

piercediverge :=
  lambda X.
    lambda _:Unit.
    fix (lambda x:X. x)

pierceexistential1 := {*Nat, {c=0, f=lambda x:Nat. succ x}}
  as {Some X, {c:X, f:X->Nat}}

pierceexistential2 := let {X,ops} = {*Nat, {c=0, f=lambda x:Nat. succ x}}
              as {Some X, {c:X, f:X->Nat}}
 in (ops.f ops.c)
